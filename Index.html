<!DOCTYPE html>
<html>

<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>PG Report</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f7f6;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .container {
      background-color: #ffffff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 400px;
      box-sizing: border-box;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 25px;
      font-size: 1.8em;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: #555;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select,
    textarea {
      width: calc(100% - 20px);
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1em;
      box-sizing: border-box;
    }

    select,
    textarea {
      width: 100%;
    }

    textarea {
      resize: vertical;
      font-family: inherit;
      min-height: 60px;
    }

    /* Product Section Styles */
    .product-section {
      margin-top: 30px;
      border-top: 2px solid #e0e0e0;
      padding-top: 20px;
    }

    .product-section h2 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 20px;
    }

    .product-tabs {
      width: 100%;
    }

    .tab-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 15px;
    }

    .tab-buttons:not(:empty) {
      border-bottom: 2px solid #e0e0e0;
    }

    .tab-button {
      padding: 8px 12px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-bottom: none;
      cursor: pointer;
      font-size: 0.9em;
      border-radius: 4px 4px 0 0;
      transition: background-color 0.2s;
      min-width: 80px;
      text-align: center;
    }

    .tab-button:hover {
      background-color: #e9ecef;
    }

    .tab-button.active {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
    }

    .tab-button.has-data {
      background-color: #28a745;
      color: white;
      border-color: #28a745;
    }

    .tab-button.has-data.active {
      background-color: #1e7e34;
      border-color: #1e7e34;
    }

    .tab-content {
      padding: 15px;
      border-radius: 0 4px 4px 4px;
      background-color: #fff;
    }

    .tab-content:has(.product-form) {
      border: 1px solid #e0e0e0;
    }

    .product-form {
      display: none;
    }

    .product-form.active {
      display: block;
    }

    .product-form label {
      margin-bottom: 5px;
      font-size: 0.9em;
    }

    .product-form input {
      margin-bottom: 10px;
      padding: 8px;
      font-size: 0.9em;
    }



    button {
      width: 100%;
      padding: 12px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    #message {
      margin-top: 20px;
      text-align: center;
      font-weight: bold;
      color: #28a745;
      /* Success color */
      min-height: 1.2em;
      /* Ensure space even when empty */
    }

    #message.error {
      color: #dc3545;
      /* Error color */
    }

    /* Sampling Activity Styles */
    .sampling-activity-entry {
      padding: 15px;
      margin-bottom: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background-color: #f8f9fa;
      position: relative;
    }

    .sampling-activity-entry label {
      font-size: 0.9em;
      margin-bottom: 5px;
    }

    .sampling-activity-entry input,
    .sampling-activity-entry select {
      margin-bottom: 10px;
      padding: 8px;
      font-size: 0.9em;
    }

    .remove-sampling-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-size: 1.2em;
      line-height: 1;
      padding: 0;
    }

    .remove-sampling-btn:hover {
      background-color: #c82333;
    }

    #addSamplingActivityBtn:hover {
      background-color: #218838;
    }

    /* Stock Balance Styles */
    .stock-balance-entry {
      padding: 15px;
      margin-bottom: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background-color: #f8f9fa;
      position: relative;
    }

    .stock-balance-entry label {
      font-size: 0.9em;
      margin-bottom: 5px;
    }

    .stock-balance-entry input,
    .stock-balance-entry select {
      margin-bottom: 10px;
      padding: 8px;
      font-size: 0.9em;
    }

    .remove-stock-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-size: 1.2em;
      line-height: 1;
      padding: 0;
    }

    .remove-stock-btn:hover {
      background-color: #c82333;
    }

    #addStockBalanceBtn:hover {
      background-color: #0056b3;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1 id="pageTitle">PG Report</h1>
    <form id="salesForm">
      <label for="name" id="labelName">Your Name:</label>
      <select id="name" name="name" required>
        <option value="">üë§ Loading names...</option>
      </select><br>

      <label for="area" id="labelArea">Area:</label>
      <select id="area" name="area" required>
        <option value="">üåç Loading areas...</option>
      </select><br>

      <label for="store" id="labelStore">Store:</label>
      <select id="store" name="store" required>
        <option value="">üè™ Loading stores...</option>
      </select><br>

      <label for="branch" id="labelBranch">Branch:</label>
      <select id="branch" name="branch" required>
        <option value="">üè¢ Select store first</option>
      </select><br>

      <label for="note" id="labelNote">Note:</label>
      <textarea id="note" name="note" placeholder="Enter any additional notes..." rows="3"></textarea><br>

      <input type="hidden" id="latitude" name="latitude">
      <input type="hidden" id="longitude" name="longitude">
    </form>

    <!-- Product Sales Section -->
    <div id="productSection" class="product-section">
      <h2 id="productSalesTitle">Product Sales</h2>

      <label for="samplingDate" id="labelSamplingDate">Sampling Date:</label>
      <input type="date" id="samplingDate" name="samplingDate" required><br>

      <label id="labelSales">Sales:</label><br>

      <div id="productTabs" class="product-tabs">
        <div id="productTabButtons" class="tab-buttons">
          <!-- Product tabs will be dynamically loaded -->
        </div>
        <div id="productTabContent" class="tab-content">
          <!-- Product content will be dynamically loaded -->
        </div>
      </div>

      <!-- Sampling Activity Section (within Product Sales) -->
      <div id="samplingActivitySection" style="margin-top: 30px;">
        <label id="labelSamplingActivity">Sampling Activity:</label><br>

        <div id="samplingActivityContainer">
          <!-- Sampling activity entries will be dynamically added here -->
        </div>

        <button type="button" id="addSamplingActivityBtn" style="width: 80%; margin-top: 10px; margin-left: 0; background-color: #28a745; font-size: 0.9em; padding: 8px;">
          + Add Sampling Activity
        </button>
      </div>

      <!-- Stock Balance Section (within Product Sales) -->
      <div id="stockBalanceSection" style="margin-top: 30px;">
        <label id="labelStockBalance">Stock Balance:</label><br>

        <div id="stockBalanceContainer">
          <!-- Stock balance entries will be dynamically added here -->
        </div>

        <button type="button" id="addStockBalanceBtn" style="width: 80%; margin-top: 10px; margin-left: 0; background-color: #28a745; font-size: 0.9em; padding: 8px;">
          + Add Stock Balance
        </button>
      </div>
    </div>

    <div style="margin-top: 30px;">
      <button type="submit" id="submitButton" form="salesForm">Register</button>
    </div>
    <div id="message"></div>
  </div>

  <script>
    const form = document.getElementById('salesForm');
    const messageDiv = document.getElementById('message');
    const latitudeInput = document.getElementById('latitude');
    const longitudeInput = document.getElementById('longitude');
    const submitButton = document.getElementById('submitButton');
    const nameSelect = document.getElementById('name');
    const areaSelect = document.getElementById('area');
    const storeSelect = document.getElementById('store');
    const branchSelect = document.getElementById('branch');
    let storesData = {};
    let productsData = [];
    let activeProductTab = null;
    let samplingActivityCounter = 0;
    let stockBalanceCounter = 0;

    // Get language from server-side template variable (defaults to "EN")
    const LANGUAGE = "<?= language ?>" || "EN";

    // Translation dictionary
    const translations = {
      EN: {
        title: "PG Report",
        yourName: "Your Name:",
        area: "Area:",
        store: "Store:",
        branch: "Branch:",
        note: "Note:",
        notePlaceholder: "Enter any additional notes...",
        productSales: "Product Sales",
        samplingDate: "Sampling Date:",
        sales: "Sales:",
        samplingActivity: "Sampling Activity:",
        addSamplingActivity: "+ Add Sampling Activity",
        stockBalance: "Stock Balance:",
        addStockBalance: "+ Add Stock Balance",
        register: "Register",
        loadingNames: "üë§ Loading names...",
        selectName: "üë§ Select your name",
        loadingAreas: "üåç Loading areas...",
        selectArea: "üåç Select area",
        loadingStores: "üè™ Loading stores...",
        selectStore: "üè™ Select store",
        selectStoreFirst: "üè¢ Select store first",
        selectAreaFirst: "üè¢ Select area first",
        selectBranch: "üè¢ Select branch",
        noBranchesAvailable: "üè¢ No branches available",
        failedToLoadNames: "‚ùå Failed to load names",
        failedToLoadAreas: "‚ùå Failed to load areas",
        failedToLoadStores: "‚ùå Failed to load stores",
        product: "Product:",
        selectProductOptional: "Select product (optional)",
        selectProduct: "Select product",
        cupsServed: "Cups Served:",
        sampleBottlesUsed: "Sample Bottles Used:",
        bottlesRemained: "No. of bottles remained:",
        bottlesSold: "No. of bottles sold",
        unitsSold: "No. of units sold",
        cartonsSold: "No. of cartons sold",
        productNote: "Product Note:",
        productNotePlaceholder: "Product-specific notes...",
        selectStoreBranchMessage: "Please select a store and branch to see available products.",
        noProductsAvailable: "No products available for this store and branch combination.",
        gettingLocation: "Getting location...",
        registering: "Registering...",
        finishRegistration: "Finish registration",
        locationDenied: "Location access denied. Please allow location access in your browser settings.",
        locationUnavailable: "Location information is unavailable.",
        locationTimeout: "The request to get user location timed out.",
        locationUnknownError: "An unknown error occurred while getting location.",
        geolocationNotSupported: "Your browser does not support geolocation.",
        locationUnavailableProceeding: "Location unavailable, proceeding with registration...",
        registrationError: "An error occurred during registration. Please try again."
      },
      VN: {
        title: "B√°o c√°o PG",
        yourName: "T√™n c·ªßa b·∫°n:",
        area: "Khu v·ª±c:",
        store: "C·ª≠a h√†ng:",
        branch: "Chi nh√°nh:",
        note: "Ghi ch√∫:",
        notePlaceholder: "Nh·∫≠p ghi ch√∫ b·ªï sung...",
        productSales: "B√°n h√†ng s·∫£n ph·∫©m",
        samplingDate: "Ng√†y l·∫•y m·∫´u:",
        sales: "B√°n h√†ng:",
        samplingActivity: "Ho·∫°t ƒë·ªông l·∫•y m·∫´u:",
        addSamplingActivity: "+ Th√™m ho·∫°t ƒë·ªông l·∫•y m·∫´u",
        stockBalance: "T·ªìn kho:",
        addStockBalance: "+ Th√™m t·ªìn kho",
        register: "ƒêƒÉng k√Ω",
        loadingNames: "üë§ ƒêang t·∫£i t√™n...",
        selectName: "üë§ Ch·ªçn t√™n c·ªßa b·∫°n",
        loadingAreas: "üåç ƒêang t·∫£i khu v·ª±c...",
        selectArea: "üåç Ch·ªçn khu v·ª±c",
        loadingStores: "üè™ ƒêang t·∫£i c·ª≠a h√†ng...",
        selectStore: "üè™ Ch·ªçn c·ª≠a h√†ng",
        selectStoreFirst: "üè¢ Ch·ªçn c·ª≠a h√†ng tr∆∞·ªõc",
        selectAreaFirst: "üè¢ Ch·ªçn khu v·ª±c tr∆∞·ªõc",
        selectBranch: "üè¢ Ch·ªçn chi nh√°nh",
        noBranchesAvailable: "üè¢ Kh√¥ng c√≥ chi nh√°nh",
        failedToLoadNames: "‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c t√™n",
        failedToLoadAreas: "‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c khu v·ª±c",
        failedToLoadStores: "‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c c·ª≠a h√†ng",
        product: "S·∫£n ph·∫©m:",
        selectProductOptional: "Ch·ªçn s·∫£n ph·∫©m (t√πy ch·ªçn)",
        selectProduct: "Ch·ªçn s·∫£n ph·∫©m",
        cupsServed: "S·ªë c·ªëc ph·ª•c v·ª•:",
        sampleBottlesUsed: "S·ªë chai m·∫´u s·ª≠ d·ª•ng:",
        bottlesRemained: "S·ªë chai c√≤n l·∫°i:",
        bottlesSold: "S·ªë chai ƒë√£ b√°n",
        unitsSold: "S·ªë ƒë∆°n v·ªã ƒë√£ b√°n",
        cartonsSold: "S·ªë th√πng ƒë√£ b√°n",
        productNote: "Ghi ch√∫ s·∫£n ph·∫©m:",
        productNotePlaceholder: "Ghi ch√∫ c·ª• th·ªÉ s·∫£n ph·∫©m...",
        selectStoreBranchMessage: "Vui l√≤ng ch·ªçn c·ª≠a h√†ng v√† chi nh√°nh ƒë·ªÉ xem s·∫£n ph·∫©m c√≥ s·∫µn.",
        noProductsAvailable: "Kh√¥ng c√≥ s·∫£n ph·∫©m n√†o cho c·ª≠a h√†ng v√† chi nh√°nh n√†y.",
        gettingLocation: "ƒêang l·∫•y v·ªã tr√≠...",
        registering: "ƒêang ƒëƒÉng k√Ω...",
        finishRegistration: "Ho√†n t·∫•t ƒëƒÉng k√Ω",
        locationDenied: "Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi. Vui l√≤ng cho ph√©p truy c·∫≠p v·ªã tr√≠ trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.",
        locationUnavailable: "Th√¥ng tin v·ªã tr√≠ kh√¥ng kh·∫£ d·ª•ng.",
        locationTimeout: "Y√™u c·∫ßu l·∫•y v·ªã tr√≠ ng∆∞·ªùi d√πng ƒë√£ h·∫øt th·ªùi gian.",
        locationUnknownError: "ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y v·ªã tr√≠.",
        geolocationNotSupported: "Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã ƒë·ªãa l√Ω.",
        locationUnavailableProceeding: "V·ªã tr√≠ kh√¥ng kh·∫£ d·ª•ng, ƒëang ti·∫øp t·ª•c ƒëƒÉng k√Ω...",
        registrationError: "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh ƒëƒÉng k√Ω. Vui l√≤ng th·ª≠ l·∫°i."
      }
    };

    // Get translation function
    function t(key) {
      return translations[LANGUAGE][key] || translations.EN[key] || key;
    }

    // Function to initialize UI with translations
    function initializeTranslations() {
      // Update static text elements
      document.getElementById('pageTitle').textContent = t('title');
      document.getElementById('labelName').textContent = t('yourName');
      document.getElementById('labelArea').textContent = t('area');
      document.getElementById('labelStore').textContent = t('store');
      document.getElementById('labelBranch').textContent = t('branch');
      document.getElementById('labelNote').textContent = t('note');
      document.getElementById('note').placeholder = t('notePlaceholder');
      document.getElementById('productSalesTitle').textContent = t('productSales');
      document.getElementById('labelSamplingDate').textContent = t('samplingDate');
      document.getElementById('labelSales').textContent = t('sales');
      document.getElementById('labelSamplingActivity').textContent = t('samplingActivity');
      document.getElementById('addSamplingActivityBtn').textContent = t('addSamplingActivity');
      document.getElementById('labelStockBalance').textContent = t('stockBalance');
      document.getElementById('addStockBalanceBtn').textContent = t('addStockBalance');
      document.getElementById('submitButton').textContent = t('register');

      // Update initial dropdown options
      nameSelect.innerHTML = `<option value="">${t('loadingNames')}</option>`;
      areaSelect.innerHTML = `<option value="">${t('loadingAreas')}</option>`;
      storeSelect.innerHTML = `<option value="">${t('loadingStores')}</option>`;
      branchSelect.innerHTML = `<option value="">${t('selectStoreFirst')}</option>`;
    }

    // Function to load names from server
    function loadNames() {
      google.script.run
        .withSuccessHandler(function (names) {
          nameSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = t('selectName');
          nameSelect.appendChild(defaultOption);

          names.forEach(function (name) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            nameSelect.appendChild(option);
          });
        })
        .withFailureHandler(function (error) {
          console.error('Failed to load names:', error);
          nameSelect.innerHTML = `<option value="">${t('failedToLoadNames')}</option>`;
          messageDiv.textContent = t('failedToLoadNames') + ': ' + error.message;
          messageDiv.className = 'error';
        })
        .getMemberList();
    }

    // Function to load areas from server
    function loadAreas() {
      google.script.run
        .withSuccessHandler(function (areas) {
          areaSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = t('selectArea');
          areaSelect.appendChild(defaultOption);

          areas.forEach(function (area) {
            const option = document.createElement('option');
            option.value = area;
            option.textContent = area;
            areaSelect.appendChild(option);
          });
        })
        .withFailureHandler(function (error) {
          console.error('Failed to load areas:', error);
          areaSelect.innerHTML = `<option value="">${t('failedToLoadAreas')}</option>`;
          messageDiv.textContent = t('failedToLoadAreas') + ': ' + error.message;
          messageDiv.className = 'error';
        })
        .getAreaList();
    }

    // Function to load products from server
    function loadProducts() {
      google.script.run
        .withSuccessHandler(function (products) {
          productsData = products;
          createProductTabs();
        })
        .withFailureHandler(function (error) {
          console.error('Failed to load products:', error);
          document.getElementById('productSection').style.display = 'none';
        })
        .getProductList();
    }

    // Function to load stores from server
    function loadStores() {
      google.script.run
        .withSuccessHandler(function (data) {
          storesData = data;
          storeSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = t('selectStore');
          storeSelect.appendChild(defaultOption);

          data.store.forEach(function (store) {
            const option = document.createElement('option');
            option.value = store;
            option.textContent = store;
            storeSelect.appendChild(option);
          });
        })
        .withFailureHandler(function (error) {
          console.error('Failed to load stores:', error);
          storeSelect.innerHTML = `<option value="">${t('failedToLoadStores')}</option>`;
          messageDiv.textContent = t('failedToLoadStores') + ': ' + error.message;
          messageDiv.className = 'error';
        })
        .getStoreList();
    }

    // Function to populate stores based on selected area
    function populateStoresByArea() {
      const selectedArea = areaSelect.value;
      storeSelect.innerHTML = '';
      branchSelect.innerHTML = '';

      if (selectedArea && storesData.areaStoreMap && storesData.areaStoreMap[selectedArea]) {
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('selectStore');
        storeSelect.appendChild(defaultOption);

        storesData.areaStoreMap[selectedArea].forEach(function (store) {
          const option = document.createElement('option');
          option.value = store;
          option.textContent = store;
          storeSelect.appendChild(option);
        });

        // Enable store select
        storeSelect.disabled = false;
      } else {
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('selectAreaFirst');
        storeSelect.appendChild(defaultOption);

        // Disable store select until area is chosen
        storeSelect.disabled = true;
      }

      // Reset branch dropdown
      const branchDefaultOption = document.createElement('option');
      branchDefaultOption.value = '';
      branchDefaultOption.textContent = t('selectStoreFirst');
      branchSelect.appendChild(branchDefaultOption);
      branchSelect.disabled = true;
    }

    // Function to populate branches based on selected area and store
    function populateBranchesByAreaAndStore() {
      const selectedArea = areaSelect.value;
      const selectedStore = storeSelect.value;
      branchSelect.innerHTML = '';

      if (selectedArea && selectedStore && storesData.areaStoreBranchMap) {
        const areaStoreKey = `${selectedArea}|${selectedStore}`;
        if (storesData.areaStoreBranchMap[areaStoreKey]) {
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = t('selectBranch');
          branchSelect.appendChild(defaultOption);

          storesData.areaStoreBranchMap[areaStoreKey].forEach(function (branch) {
            const option = document.createElement('option');
            option.value = branch;
            option.textContent = branch;
            branchSelect.appendChild(option);
          });

          // Enable branch select
          branchSelect.disabled = false;
        } else {
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = t('noBranchesAvailable');
          branchSelect.appendChild(defaultOption);
          branchSelect.disabled = true;
        }
      } else if (selectedArea && !selectedStore) {
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('selectStoreFirst');
        branchSelect.appendChild(defaultOption);
        branchSelect.disabled = true;
      } else {
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = t('selectAreaFirst');
        branchSelect.appendChild(defaultOption);
        branchSelect.disabled = true;
      }
    }

    // Handle branch selection to update product tabs
    branchSelect.addEventListener('change', function () {
      updateProductTabs(); // Update products when branch changes
      updateAllSamplingProductDropdowns(); // Update sampling activity dropdowns
      updateAllStockProductDropdowns(); // Update stock balance dropdowns
    });

    // Handle area selection to populate stores and reset branches
    areaSelect.addEventListener('change', function () {
      populateStoresByArea();
      populateBranchesByAreaAndStore(); // Reset branches
    });

    // Handle store selection to populate branches
    storeSelect.addEventListener('change', function () {
      populateBranchesByAreaAndStore();
      updateProductTabs(); // Update products when store changes
      updateAllSamplingProductDropdowns(); // Update sampling activity dropdowns
      updateAllStockProductDropdowns(); // Update stock balance dropdowns
    });

    // Function to get product icon based on type
    function getProductIcon(productType) {
      const type = productType.toLowerCase();
      if (type.includes('rtd')) {
        return 'üçµ'; // tea icon for RTD
      } else if (type.includes('leaf')) {
        return 'üåø'; // leaf icon for Leaf products
      }
      return 'üì¶'; // default package icon
    }

    // Function to create product tabs (initial load - shows instruction message)
    function createProductTabs() {
      const tabButtons = document.getElementById('productTabButtons');
      const tabContent = document.getElementById('productTabContent');

      tabButtons.innerHTML = '';
      tabContent.innerHTML = '';

      if (productsData.length === 0) {
        document.getElementById('productSection').style.display = 'none';
        return;
      }

      // Show instruction message initially
      const instructionMessage = document.createElement('div');
      instructionMessage.style.textAlign = 'center';
      instructionMessage.style.padding = '20px';
      instructionMessage.style.color = '#666';
      instructionMessage.textContent = t('selectStoreBranchMessage');
      tabContent.appendChild(instructionMessage);
    }

    // Function to switch product tabs
    function switchProductTab(index) {
      // Remove active class from all buttons and forms
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.product-form').forEach(form => form.classList.remove('active'));

      // Add active class to selected button and form
      document.querySelectorAll('.tab-button')[index].classList.add('active');
      document.getElementById(`product-form-${index}`).classList.add('active');

      activeProductTab = index;
    }

    // Load names, areas, stores, and products when page loads
    window.addEventListener('load', function () {
      // Initialize translations first
      initializeTranslations();

      loadNames();
      loadAreas();
      loadStores();
      loadProducts();

      // Initially disable store and branch selects
      storeSelect.disabled = true;
      branchSelect.disabled = true;

      // Set default sampling date to today
      const samplingDateInput = document.getElementById('samplingDate');
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, '0');
      const dd = String(today.getDate()).padStart(2, '0');
      const todayStr = `${yyyy}-${mm}-${dd}`;
      samplingDateInput.value = todayStr;
    });

    // Sampling Activity Functions
    function addSamplingActivity() {
      const container = document.getElementById('samplingActivityContainer');
      const entryId = samplingActivityCounter++;

      const entryDiv = document.createElement('div');
      entryDiv.className = 'sampling-activity-entry';
      entryDiv.id = `sampling-entry-${entryId}`;
      entryDiv.innerHTML = `
        <button type="button" class="remove-sampling-btn" onclick="removeSamplingActivity(${entryId})">√ó</button>

        <label for="sampling-product-${entryId}">${t('product')}</label>
        <select id="sampling-product-${entryId}" class="sampling-product-select">
          <option value="">${t('selectProductOptional')}</option>
        </select>

        <label for="sampling-cups-${entryId}">${t('cupsServed')}</label>
        <input type="number" id="sampling-cups-${entryId}" min="0" placeholder="0">

        <label for="sampling-bottles-${entryId}">${t('sampleBottlesUsed')}</label>
        <input type="number" id="sampling-bottles-${entryId}" min="0" placeholder="0">
      `;

      container.appendChild(entryDiv);

      // Populate product dropdown
      populateSamplingProductDropdown(entryId);

      // Add change listener to refresh all dropdowns when selection changes
      document.getElementById(`sampling-product-${entryId}`).addEventListener('change', function() {
        updateAllSamplingProductDropdowns();
      });
    }

    function populateSamplingProductDropdown(entryId) {
      const select = document.getElementById(`sampling-product-${entryId}`);
      if (!select) return;

      // Get currently selected value to preserve it
      const currentValue = select.value;

      // Clear existing options except the first one
      select.innerHTML = `<option value="">${t('selectProductOptional')}</option>`;

      // Get available products for the selected store/branch
      const availableProducts = getAvailableProducts();

      // Get already selected products in other Sampling Activity entries
      const container = document.getElementById('samplingActivityContainer');
      const entries = container.querySelectorAll('.sampling-activity-entry');
      const selectedProducts = new Set();

      entries.forEach(entry => {
        const otherId = entry.id.replace('sampling-entry-', '');
        if (otherId !== entryId.toString()) {
          const otherSelect = document.getElementById(`sampling-product-${otherId}`);
          if (otherSelect && otherSelect.value !== '') {
            selectedProducts.add(otherSelect.value);
          }
        }
      });

      // Add only available products that are not already selected
      availableProducts.forEach((product) => {
        const originalIndex = productsData.indexOf(product);
        const indexStr = originalIndex.toString();

        // Skip if already selected in another entry (unless it's the current value)
        if (!selectedProducts.has(indexStr) || indexStr === currentValue) {
          const option = document.createElement('option');
          option.value = originalIndex;
          const icon = getProductIcon(product.type);
          option.textContent = `${icon} ${product.type} - ${product.name}`;
          select.appendChild(option);
        }
      });

      // Restore the previously selected value if it still exists
      if (currentValue !== '') {
        select.value = currentValue;
      }
    }

    // Function to update all sampling product dropdowns
    function updateAllSamplingProductDropdowns() {
      const container = document.getElementById('samplingActivityContainer');
      if (!container) return;

      const entries = container.querySelectorAll('.sampling-activity-entry');
      entries.forEach(entry => {
        const entryId = entry.id.replace('sampling-entry-', '');
        populateSamplingProductDropdown(entryId);
      });
    }

    function removeSamplingActivity(entryId) {
      const entry = document.getElementById(`sampling-entry-${entryId}`);
      if (entry) {
        entry.remove();
      }
    }

    function collectSamplingActivities() {
      const container = document.getElementById('samplingActivityContainer');
      const entries = container.querySelectorAll('.sampling-activity-entry');
      const activities = [];

      entries.forEach(entry => {
        const entryId = entry.id.replace('sampling-entry-', '');
        const productIndex = document.getElementById(`sampling-product-${entryId}`).value;
        const cupsServed = document.getElementById(`sampling-cups-${entryId}`).value;
        const bottlesUsed = document.getElementById(`sampling-bottles-${entryId}`).value;

        // Only include if at least one field has meaningful data
        const hasProductIndex = productIndex !== '' && productIndex !== null;
        const hasCupsServed = cupsServed !== '' && cupsServed !== null && cupsServed !== '0';
        const hasBottlesUsed = bottlesUsed !== '' && bottlesUsed !== null && bottlesUsed !== '0';

        if (hasProductIndex || hasCupsServed || hasBottlesUsed) {
          const parsedProductIndex = productIndex !== '' ? parseInt(productIndex) : null;
          activities.push({
            productIndex: parsedProductIndex,
            productType: parsedProductIndex !== null && productsData[parsedProductIndex] ? productsData[parsedProductIndex].type : '',
            productName: parsedProductIndex !== null && productsData[parsedProductIndex] ? productsData[parsedProductIndex].name : '',
            cupsServed: cupsServed || 0,
            bottlesUsed: bottlesUsed || 0
          });
        }
      });

      return activities;
    }

    function clearSamplingActivities() {
      const container = document.getElementById('samplingActivityContainer');
      container.innerHTML = '';
      samplingActivityCounter = 0;
    }

    // Add event listener for add sampling activity button
    document.getElementById('addSamplingActivityBtn').addEventListener('click', addSamplingActivity);

    // Helper function to get selected products in Sampling Activity
    function getSelectedSamplingProducts() {
      const container = document.getElementById('samplingActivityContainer');
      const entries = container.querySelectorAll('.sampling-activity-entry');
      const selectedProducts = new Set();

      entries.forEach(entry => {
        const entryId = entry.id.replace('sampling-entry-', '');
        const select = document.getElementById(`sampling-product-${entryId}`);
        if (select && select.value !== '') {
          selectedProducts.add(select.value);
        }
      });

      return selectedProducts;
    }

    // Helper function to get selected products in Stock Balance
    function getSelectedStockProducts() {
      const container = document.getElementById('stockBalanceContainer');
      const entries = container.querySelectorAll('.stock-balance-entry');
      const selectedProducts = new Set();

      entries.forEach(entry => {
        const entryId = entry.id.replace('stock-entry-', '');
        const select = document.getElementById(`stock-product-${entryId}`);
        if (select && select.value !== '') {
          selectedProducts.add(select.value);
        }
      });

      return selectedProducts;
    }

    // Stock Balance Functions
    function addStockBalance() {
      const container = document.getElementById('stockBalanceContainer');
      const entryId = stockBalanceCounter++;

      const entryDiv = document.createElement('div');
      entryDiv.className = 'stock-balance-entry';
      entryDiv.id = `stock-entry-${entryId}`;
      entryDiv.innerHTML = `
        <button type="button" class="remove-stock-btn" onclick="removeStockBalance(${entryId})">√ó</button>

        <label for="stock-product-${entryId}">${t('product')}</label>
        <select id="stock-product-${entryId}" class="stock-product-select">
          <option value="">${t('selectProduct')}</option>
        </select>

        <label for="stock-bottles-${entryId}">${t('bottlesRemained')}</label>
        <input type="number" id="stock-bottles-${entryId}" min="0" placeholder="0">
      `;

      container.appendChild(entryDiv);

      // Populate product dropdown
      populateStockProductDropdown(entryId);

      // Add change listener to refresh all dropdowns when selection changes
      document.getElementById(`stock-product-${entryId}`).addEventListener('change', function() {
        updateAllStockProductDropdowns();
      });
    }

    function populateStockProductDropdown(entryId) {
      const select = document.getElementById(`stock-product-${entryId}`);
      if (!select) return;

      // Get currently selected value to preserve it
      const currentValue = select.value;

      // Clear existing options except the first one
      select.innerHTML = `<option value="">${t('selectProduct')}</option>`;

      // Get available products for the selected store/branch
      const availableProducts = getAvailableProducts();

      // Get already selected products in other Stock Balance entries
      const container = document.getElementById('stockBalanceContainer');
      const entries = container.querySelectorAll('.stock-balance-entry');
      const selectedProducts = new Set();

      entries.forEach(entry => {
        const otherId = entry.id.replace('stock-entry-', '');
        if (otherId !== entryId.toString()) {
          const otherSelect = document.getElementById(`stock-product-${otherId}`);
          if (otherSelect && otherSelect.value !== '') {
            selectedProducts.add(otherSelect.value);
          }
        }
      });

      // Add only available products that are not already selected
      availableProducts.forEach((product) => {
        const originalIndex = productsData.indexOf(product);
        const indexStr = originalIndex.toString();

        // Skip if already selected in another entry (unless it's the current value)
        if (!selectedProducts.has(indexStr) || indexStr === currentValue) {
          const option = document.createElement('option');
          option.value = originalIndex;
          const icon = getProductIcon(product.type);
          option.textContent = `${icon} ${product.type} - ${product.name}`;
          select.appendChild(option);
        }
      });

      // Restore the previously selected value if it still exists
      if (currentValue !== '') {
        select.value = currentValue;
      }
    }

    // Function to update all stock balance product dropdowns
    function updateAllStockProductDropdowns() {
      const container = document.getElementById('stockBalanceContainer');
      if (!container) return;

      const entries = container.querySelectorAll('.stock-balance-entry');
      entries.forEach(entry => {
        const entryId = entry.id.replace('stock-entry-', '');
        populateStockProductDropdown(entryId);
      });
    }

    function removeStockBalance(entryId) {
      const entry = document.getElementById(`stock-entry-${entryId}`);
      if (entry) {
        entry.remove();
      }
    }

    function collectStockBalances() {
      const container = document.getElementById('stockBalanceContainer');
      const entries = container.querySelectorAll('.stock-balance-entry');
      const stockBalances = [];

      entries.forEach(entry => {
        const entryId = entry.id.replace('stock-entry-', '');
        const productIndex = document.getElementById(`stock-product-${entryId}`).value;
        const bottlesRemained = document.getElementById(`stock-bottles-${entryId}`).value;

        // Only include if both product and bottles are specified
        if (productIndex !== '' && productIndex !== null && bottlesRemained !== '' && bottlesRemained !== null) {
          const parsedProductIndex = parseInt(productIndex);
          stockBalances.push({
            productIndex: parsedProductIndex,
            productType: productsData[parsedProductIndex] ? productsData[parsedProductIndex].type : '',
            productName: productsData[parsedProductIndex] ? productsData[parsedProductIndex].name : '',
            bottlesRemained: bottlesRemained || 0
          });
        }
      });

      return stockBalances;
    }

    function clearStockBalances() {
      const container = document.getElementById('stockBalanceContainer');
      container.innerHTML = '';
      stockBalanceCounter = 0;
    }

    // Add event listener for add stock balance button
    document.getElementById('addStockBalanceBtn').addEventListener('click', addStockBalance);

    // Function to get geolocation
    function getLocation() {
      return new Promise((resolve, reject) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              latitudeInput.value = position.coords.latitude;
              longitudeInput.value = position.coords.longitude;
              resolve();
            },
            (error) => {
              console.error("Failed to get location:", error);
              let errorMessage = '';
              switch (error.code) {
                case error.PERMISSION_DENIED:
                  errorMessage = t('locationDenied');
                  break;
                case error.POSITION_UNAVAILABLE:
                  errorMessage = t('locationUnavailable');
                  break;
                case error.TIMEOUT:
                  errorMessage = t('locationTimeout');
                  break;
                case error.UNKNOWN_ERROR:
                  errorMessage = t('locationUnknownError');
                  break;
              }
              messageDiv.textContent = errorMessage;
              messageDiv.className = 'error'; // Add error class for styling
              reject(error);
            },
            {
              enableHighAccuracy: true,
              timeout: 10000, // Increased timeout for potentially slower mobile connections
              maximumAge: 0
            }
          );
        } else {
          messageDiv.textContent = t('geolocationNotSupported');
          messageDiv.className = 'error';
          reject(new Error("Geolocation not supported"));
        }
      });
    }


    // Function to collect product sales data
    function collectProductData() {
      const productSales = [];
      const availableProducts = getAvailableProducts();

      // Include ALL available products - validation ensures they all have required data
      availableProducts.forEach((product, tabIndex) => {
        const salesCount = document.getElementById(`product-sales-${tabIndex}`).value;
        const samplingCount = document.getElementById(`product-sampling-${tabIndex}`).value;
        const productNote = document.getElementById(`product-note-${tabIndex}`).value || '';

        productSales.push({
          type: product.type,
          name: product.name,
          salesCount: salesCount,
          samplingCount: samplingCount,
          note: productNote
        });
      });

      return productSales;
    }

    // Function to validate product sales
    function validateProductSales(productSales) {
      const availableProducts = getAvailableProducts();

      if (availableProducts.length === 0) {
        messageDiv.textContent = t('noProductsAvailable');
        messageDiv.className = 'error';
        return false;
      }

      let validationErrors = [];

      // ALL available products must have their required fields filled
      availableProducts.forEach((product, tabIndex) => {
        const salesCount = document.getElementById(`product-sales-${tabIndex}`).value;
        const samplingCount = document.getElementById(`product-sampling-${tabIndex}`).value;

        // Determine the label based on product type
        const salesLabel = product.type.toLowerCase().includes('rtd') ? t('bottlesSold') : t('unitsSold');

        // Sales and sampling counts are always required
        if (!salesCount || salesCount === '') {
          validationErrors.push(`${product.name}: ${salesLabel} is required`);
        }
        if (!samplingCount || samplingCount === '') {
          validationErrors.push(`${product.name}: ${t('cartonsSold')} is required`);
        }
      });

      if (validationErrors.length > 0) {
        messageDiv.textContent = validationErrors[0]; // Show first error
        messageDiv.className = 'error';
        return false;
      }

      return true;
    }

    // Function to clear all product form data
    function clearProductForms() {
      const availableProducts = getAvailableProducts();
      availableProducts.forEach((product, tabIndex) => {
        const salesInput = document.getElementById(`product-sales-${tabIndex}`);
        const samplingInput = document.getElementById(`product-sampling-${tabIndex}`);
        const noteInput = document.getElementById(`product-note-${tabIndex}`);
        
        if (salesInput) salesInput.value = '';
        if (samplingInput) samplingInput.value = '';
        if (noteInput) noteInput.value = '';
      });
      
      // Update visual indicators for all visible tabs
      availableProducts.forEach((product, tabIndex) => {
        updateTabIndicatorForFiltered(tabIndex);
      });
    }

    // Function to check if a product tab has any data
    function hasProductData(index) {
      const salesCount = document.getElementById(`product-sales-${index}`).value;
      const samplingCount = document.getElementById(`product-sampling-${index}`).value;
      const productNote = document.getElementById(`product-note-${index}`).value;
      
      return salesCount || samplingCount || productNote;
    }

    // Function to update tab visual indicator
    function updateTabIndicator(index) {
      const tabButton = document.querySelectorAll('.tab-button')[index];
      const icon = getProductIcon(productsData[index].type);
      
      if (hasProductData(index)) {
        tabButton.classList.add('has-data');
        tabButton.innerHTML = `‚úÖ ${icon} ${productsData[index].name}`;
      } else {
        tabButton.classList.remove('has-data');
        tabButton.innerHTML = `${icon} ${productsData[index].name}`;
      }
    }

    // Function to update all tab indicators
    function updateAllTabIndicators() {
      productsData.forEach((product, index) => {
        updateTabIndicator(index);
      });
    }

    // Function to get available products for selected store and branch
    function getAvailableProducts() {
      const selectedStore = storeSelect.value;
      const selectedBranch = branchSelect.value;
      
      if (!selectedStore || !selectedBranch || !storesData.storeBranchProductMap) {
        return []; // No products available if store/branch not selected
      }
      
      const storeBranchKey = `${selectedStore}|${selectedBranch}`;
      const availableProductIndices = storesData.storeBranchProductMap[storeBranchKey] || [];
      
      // Filter products based on available indices
      return productsData.filter((product, index) => availableProductIndices.includes(index));
    }

    // Function to update product tabs based on store/branch selection
    function updateProductTabs() {
      const availableProducts = getAvailableProducts();
      const tabButtons = document.getElementById('productTabButtons');
      const tabContent = document.getElementById('productTabContent');

      // Clear existing tabs
      tabButtons.innerHTML = '';
      tabContent.innerHTML = '';

      if (availableProducts.length === 0) {
        // Show message when no products are available
        const noProductsMessage = document.createElement('div');
        noProductsMessage.style.textAlign = 'center';
        noProductsMessage.style.padding = '20px';
        noProductsMessage.style.color = '#666';
        noProductsMessage.textContent = t('noProductsAvailable');
        tabContent.appendChild(noProductsMessage);
        return;
      }

      // Create tabs for available products
      availableProducts.forEach((product, tabIndex) => {
        const originalIndex = productsData.indexOf(product);

        // Create tab button with icon
        const tabButton = document.createElement('div');
        tabButton.className = 'tab-button';
        const icon = getProductIcon(product.type);
        tabButton.innerHTML = `${icon} ${product.name}`;
        tabButton.onclick = () => switchProductTab(tabIndex);
        tabButtons.appendChild(tabButton);

        // Create tab content
        const productForm = document.createElement('div');
        productForm.className = 'product-form';
        productForm.id = `product-form-${tabIndex}`;

        // Determine the label based on product type
        const salesLabel = product.type.toLowerCase().includes('rtd') ? t('bottlesSold') : t('unitsSold');

        productForm.innerHTML = `
          <h3>${product.type} - ${product.name}</h3>
          <label for="product-sales-${tabIndex}">${salesLabel}: <span style="color: red;">*</span></label>
          <input type="number" id="product-sales-${tabIndex}" min="0" placeholder="-" required>

          <label for="product-sampling-${tabIndex}">${t('cartonsSold')}: <span style="color: red;">*</span></label>
          <input type="number" id="product-sampling-${tabIndex}" min="0" placeholder="-" required>

          <label for="product-note-${tabIndex}">${t('productNote')}</label>
          <textarea id="product-note-${tabIndex}" rows="2" placeholder="${t('productNotePlaceholder')}"></textarea>
        `;
        tabContent.appendChild(productForm);

        // Add event listeners to update tab indicator when data changes
        const currentTabIndex = tabIndex;
        ['input', 'change'].forEach(eventType => {
          document.getElementById(`product-sales-${currentTabIndex}`).addEventListener(eventType, () => {
            updateTabIndicatorForFiltered(currentTabIndex);
          });
          document.getElementById(`product-sampling-${currentTabIndex}`).addEventListener(eventType, () => {
            updateTabIndicatorForFiltered(currentTabIndex);
          });
          document.getElementById(`product-note-${currentTabIndex}`).addEventListener(eventType, () => updateTabIndicatorForFiltered(currentTabIndex));
        });
      });

      // Activate first tab if available
      if (availableProducts.length > 0) {
        switchProductTab(0);
      }
    }


    // Function to update tab indicator for filtered products
    function updateTabIndicatorForFiltered(tabIndex) {
      const tabButton = document.querySelectorAll('.tab-button')[tabIndex];
      const availableProducts = getAvailableProducts();
      
      if (tabIndex >= availableProducts.length) return;
      
      const product = availableProducts[tabIndex];
      const icon = getProductIcon(product.type);
      
      // Check if this tab has complete required data
      const salesCount = document.getElementById(`product-sales-${tabIndex}`).value;
      const samplingCount = document.getElementById(`product-sampling-${tabIndex}`).value;
      
      // Check if ALL required fields are complete
      let hasCompleteData = false;
      
      // Sales and sampling counts are always required
      if (salesCount !== '' && samplingCount !== '') {
        hasCompleteData = true;
      }
      
      if (hasCompleteData) {
        tabButton.classList.add('has-data');
        tabButton.innerHTML = `‚úÖ ${icon} ${product.name}`;
      } else {
        tabButton.classList.remove('has-data');
        tabButton.innerHTML = `${icon} ${product.name}`;
      }
    }

    form.addEventListener('submit', async function (event) {
      event.preventDefault(); // Prevent default form submission

      submitButton.disabled = true; // Disable button to prevent multiple submissions
      messageDiv.textContent = t('gettingLocation');
      messageDiv.className = ''; // Reset class

      // Try to get location, but don't fail if it's not available
      try {
        await getLocation();
      } catch (locationError) {
        console.log('Location could not be obtained:', locationError);
        // Set placeholder values to indicate GPS failure
        latitudeInput.value = 'GPS_FAILED';
        longitudeInput.value = 'GPS_FAILED';
        messageDiv.textContent = t('locationUnavailableProceeding');
      }

      try {
        const formData = new FormData(form);
        const params = new URLSearchParams();
        for (const pair of formData) {
          params.append(pair[0], pair[1]);
        }

        // Add product sales data
        const productSales = collectProductData();

        // Validate that at least one product has sales data
        if (!validateProductSales(productSales)) {
          submitButton.disabled = false; // Re-enable button when validation fails
          return;
        }

        params.append('productInventory', JSON.stringify(productSales));

        // Add sampling date (already in YYYY-MM-DD format from date input)
        const samplingDate = document.getElementById('samplingDate').value;
        params.append('samplingDate', samplingDate);

        // Add sampling activities data
        const samplingActivities = collectSamplingActivities();
        params.append('samplingActivities', JSON.stringify(samplingActivities));

        // Add stock balances data
        const stockBalances = collectStockBalances();
        params.append('stockBalances', JSON.stringify(stockBalances));

        messageDiv.textContent = t('registering');

        // IMPORTANT: Replace 'YOUR_DEPLOYED_WEB_APP_URL' with your actual GAS Web App URL
        const response = await fetch('YOUR_DEPLOYED_WEB_APP_URL', {
          method: 'POST',
          body: params,
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        });

        const data = await response.json();
        if (data.status === 'success') {
          messageDiv.textContent = t('finishRegistration');
          messageDiv.className = ''; // Success class is default (no error class)

          // Clear form but keep Name, Area, and Sampling Date values
          const nameValue = nameSelect.value;
          const areaValue = areaSelect.value;
          const samplingDateValue = document.getElementById('samplingDate').value;

          form.reset(); // Reset main form
          clearProductForms(); // Clear all product form data
          clearSamplingActivities(); // Clear all sampling activities
          clearStockBalances(); // Clear all stock balances

          // Restore Name, Area, and Sampling Date values
          nameSelect.value = nameValue;
          areaSelect.value = areaValue;
          document.getElementById('samplingDate').value = samplingDateValue;

          // Re-populate stores and branches based on the kept area selection
          if (areaValue) {
            populateStoresByArea();
          }

          // Clear product tabs since store/branch were reset
          updateProductTabs();
        } else {
          messageDiv.textContent = 'Error: ' + data.message;
          messageDiv.className = 'error'; // Add error class
        }
      } catch (error) {
        console.error('Error during registration process:', error);
        messageDiv.textContent = t('registrationError');
        messageDiv.className = 'error';
      } finally {
        submitButton.disabled = false; // Re-enable button
      }
    });
  </script>
</body>

</html>